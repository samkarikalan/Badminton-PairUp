<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Badminton Pair-UP</title>
  <style>
/* === GLOBAL === */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #3b0073, #7d00b8);
      color: white;
      text-align: center;
      overflow-x: hidden;
    }

    header {
      padding: 8px;
    }

    h1 {
      font-size: 20px;
      margin: 0;
      font-weight: bold;
      letter-spacing: 2px;
    }

    h3 {
      font-size: 15px;
      margin: 8px 0;
      color: #3a1818;
    }

    /* === CONTAINER & CARD === */
    .container {
      max-width: 800px;
      margin: auto;
      padding: 8px;
    }

    .card,
.match-card{
  background: white;
  color: black;
  padding: 12px;
  margin-bottom: 8px;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  width: 550px;
  max-width: 95vw;
  box-sizing: border-box;
}

.rest-box {
  background: transparent !important;
  color: black;
  padding: 12px;
  margin-bottom: 8px;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  width: 550px;
  max-width: 95vw;
  box-sizing: border-box;
  
  display: flex;          /* enables gap */
  flex-wrap: wrap;        /* allows buttons to wrap to new lines */
  justify-content: center;/* optional: center buttons */
  align-items: center;    /* vertically align */
  gap: 12px;              /* space between buttons */
}
    
    /* === FORM ELEMENTS === */
    .card input,
    .card select,   
    .card button {
      width: 100%;
      padding: 8px;
      margin: 8px 0;
      font-size: 16px;
      border-radius: 6px;
      box-sizing: border-box;
    }

    .card input,
    .card select {
      border: 1px solid #ccc;
    }

     /* === BUTTONS === */
    .card button {
      background: purple;
      color: white;
      border: none;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.3s, transform 0.2s;
    }

    .card button:hover {
      background: #5e009c;
      transform: scale(1.05);
    }

    /* === TABLE === */  

    #player-list-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 2px;
    }
    
    #player-list-table th, #player-list-table td {
      border: 1px solid #ccc;
      padding: 6px;
      text-align: center;
      font-size: 14px;
    }
    #player-list-table th {
      background: #f2f2f2;
    }
    .delete-btn {
      background: none;
      border: none;
      color: #d11a2a;
      font-size: 8px;
      cursor: pointer;
    }
    .delete-btn:hover {
      color: #a00;
    }
    .fixed-pairs-list {
      margin-top: 8px;
    }
    .fixed-pair-item {
      background: #eee;
      color: black;
      padding: 6px 8px;
      border-radius: 6px;
      margin: 5px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .fixed-pair-remove {
      color: #d11a2a;
      cursor: pointer;
      margin-left: 8px;
    }
    .fixed-pair-remove:hover {
      color: #a00;
    }
        
    /* === Modal === */
    #importModal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.6);
      z-index: 1000;
    }
    #importModal .modal-content {
      background: white;
      color: black;
      max-width: 400px;
      margin: 100px auto;
      padding: 20px;
      border-radius: 10px;
    }
    #importModal button {
      margin-top: 10px;
      padding: 8px 12px;
      border-radius: 6px;
    }
    .ok-btn {
      background: #009c3c;
      color: white;
      border: none;
      font-weight: bold;
      cursor: pointer;
    }
    .ok-btn:hover {
      background: #00b84d;
    }

/* === PAGE 2: Match Results / Court Layout === */
    .main-action {
      display: block;
      width: 100%;
      background: orange;
      color: black;
      font-size: 20px;
      font-weight: bold;
      padding: 8px;
      border-radius: 8px;
      margin-top: 8px;
      cursor: pointer;
      border: none;
      transition: background 0.3s, transform 0.2s;
    }
    .main-action:hover {
      background: #ffb84d;
      transform: scale(1.05);
    }
    #game-results {      
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px; /* uniform spacing between match cards */
      padding: 16px;
      background: linear-gradient(180deg, #3b0073 0%, #7d00b8 100%);
      min-height: 40vh;
    }

/* === Match Card === */
  

    .match-card h3 {
      font-size: 22px;
      margin: 0; /* reset */
    }

    .match-card .teams {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8x; /* consistent gap between teams */
    }

.team {
  display: flex;
  flex-direction: column;
  flex: 1;
  min-width: 120px;
}

.vs-text {
  font-size: 20px;
  font-weight: bold;
  color: #3b0073;
  flex: 0 0 auto;
  margin: 0 8px; /* balanced spacing */
}

.Lplayer-btn,
.Rplayer-btn {
  border: none;
  border-radius: 6px;
  font-size: 16px;
  padding: 10px;
  margin: 4px 0;
  color: #fff;
  text-align: center;
  transition: transform 0.2s, background 0.2s;
}

.Lplayer-btn { background: #009c3c; }
.Rplayer-btn { background: #0494ad; }

.Lplayer-btn:hover { background: #34995b; transform: scale(1.03); }
.Rplayer-btn:hover { background: #3f8e9c; transform: scale(1.03); }

.match-time {
  font-size: 16px;
  color: #3b0073;
  font-weight: 600;
  margin-top: 4px;
}

/* === Round Navigation === */
.round-navigation {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 16px;
  margin-top: 12px;
  padding: 8px 16px;
  background: linear-gradient(135deg, #2a2a72, #009ffd);
  border-radius: 12px;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
}

.round-navigation .round-label {
  color: #fff;
  font-weight: 600;
  font-size: 1rem;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

.round-navigation button {
  background: #fff;
  border: none;
  padding: 8px 16px;
  font-size: 0.95rem;
  font-weight: 600;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.25s ease;
  min-width: 50px;
}

.round-navigation button:hover:enabled {
  background: #009ffd;
  color: #fff;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  transform: translateY(-1px);
}

.round-navigation button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* === Rest Section === */

.rest-btn {
  border: none;
  border-radius: 6px;
  font-size: 16px;
  padding: 10px;
  margin: 4px 0;
  color: #fff;
  text-align: center;
  transition: transform 0.2s, background 0.2s;
}
.:hover {
  transform: scale(1.05);
  opacity: 0.9;
}
    
.rest-box.drag-over {
  outline: 3px dashed #ff9800;
}

.rest-box:empty {
  min-height: 40px;
}

., .Lplayer-btn, .Rplayer-btn {
  cursor: grab;
  margin: 2px;
}
#importModal .modal-content {
  background: white;
  color: black;
  max-width: 400px;
  margin: 100px auto;
  padding: 20px;
  border-radius: 10px;
  display: flex;
  flex-direction: column;
   justify-content: center;
}

#importModal textarea {
  width: 100%;
  box-sizing: border-box;
  margin-bottom: 15px;
  padding: 8px;
  border-radius: 6px; 
  resize: vertical;
}

.modal-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 10px; /* spacing between buttons */
}

.ok-btn {
  background: #009c3c;
  color: white;
  border: none;
  font-weight: bold;
  cursor: pointer;
  padding: 8px 12px;
  border-radius: 6px;
}

.ok-btn:hover {
  background: #00b84d;
}

.cancel-btn {
  background: #d11a2a;
  color: white;
  border: none;
  font-weight: bold;
  cursor: pointer;
  padding: 8px 12px;
  border-radius: 6px;
}

.cancel-btn:hover {
  background: #ff3b3b;
}

.round-title {
  display: inline-block;
  background: #007BFF;
  color: white;
  padding: 8px 20px;
  border-radius: 14px;
  font-weight: 700;
  font-size: 1.4rem;  /* 👈 Larger text */
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.25);
  margin: 10px 0;
}

  </style>
</head>
<body onload="initPage()">

  <!-- Page 1 -->
  <div id="page1">
    <div class="container">
      <h1>Kari Scheduler</h1>

      <!-- Import Players -->
      <div class="card">
        <button onclick="showImportModal()">Paste All Players</button>
      </div>
        <div id="importModal">
          <div class="modal-content">
          <textarea id="players-textarea" rows="8" placeholder="Name,Gender&#10;Kari,Male&#10;Bhavani,Female"></textarea>
          <div class="modal-buttons">
            <button class="ok-btn" onclick="addPlayersFromText()">Import</button>
            <button class="cancel-btn" onclick="hideImportModal()">Cancel</button>
          </div>
        </div>
      </div>
      <!-- Add Player Form -->
      <div class="card">
        <input type="text" id="player-name" placeholder="Enter Player Name">
        <select id="player-gender">
          <option value="Male">Male</option>
          <option value="Female">Female</option>
        </select>
        <button onclick="addPlayer()">Add Player</button>
      </div>

      <!-- Players List -->
      <div class="card">
        <table id="player-list-table"></table>
      </div>

      <!-- Fixed Pairs -->
       
      <div class="card">
        <h3>Set Fixed Pairs (Optional)</h3>
        <select id="fixed-pair-1"></select>
        <select id="fixed-pair-2"></select>
        <button onclick="addFixedPair()">Add Fixed Pair</button>
        <div id="fixed-pair-list" class="fixed-pairs-list"></div>
      </div>

      <!-- Game Setup -->
      <div class="card">
        <!--<h3>Setup Matches</h3> -->
        <input type="number" id="num-courts" placeholder="Enter Number of Courts" min="1">        
      </div>

      <!-- Go to Rounds -->    
       <button id="goToRoundsBtn" class="main-action" onclick="goToRounds()">Go to Rounds ➡️</button>

      <!--<button class="main-action" onclick="goToRounds()" style="display:none;">Go to Rounds ➡️</button>            -->
    </div>
  </div>

  <!-- Page 2 -->
  <div id="page2" style="display:none;">
    <header>
      <!--<h1>BADMINTON</h1> -->
      <h4 id="roundTitle">Championship</h4>
    </header>

    <div id="game-results"></div>
     
    <div class="round-navigation">      
      <button id="prevBtn" onclick="prevRound()" disabled>Prev Round</button>
      <button id="nextBtn" onclick="nextRound()" disabled>NextRound</button>      
    </div>
    
    <!-- Back button -->
     <button class="main-action" onclick="goBack()">Back</button>    
  </div>
<!DOCTYPE html>
<script>
/* =========================
   GLOBAL STATE
========================= */
let players = [];
let fixedPairs = [];
let allRounds = [];
let currentRoundIndex = 0;
let playedAgainst = new Set();

let schedulerState = {
  players: [],
  numCourts: 0,
  fixedPairs: [],
  restCount: new Map(),
  playedTogether: new Map(),
  fixedMap: new Map(),
  roundIndex: 0,
  pairPlayedSet :new Set(),
};


let isOnPage2 = false;

// Disable pull-to-refresh by forcing overscroll-behavior
function disablePullToRefresh() {
  document.body.style.overscrollBehaviorY = 'none';
  document.documentElement.style.overscrollBehaviorY = 'none';
}

// Re-enable normal scroll
function enablePullToRefresh() {
  document.body.style.overscrollBehaviorY = '';
  document.documentElement.style.overscrollBehaviorY = '';
}
/* =========================
   INITIALIZATION
========================= */
function initPage() {
  document.getElementById("page1").style.display = 'block';
  document.getElementById("page2").style.display = 'none';
}

/* =========================
   PLAYER MANAGEMENT
========================= */
function showImportModal() {
  document.getElementById('importModal').style.display = 'block';
}

function hideImportModal() {
  document.getElementById('importModal').style.display = 'none';
  document.getElementById('players-textarea').value = '';
}

function addPlayersFromText() {
  const text = document.getElementById('players-textarea').value.trim();
  if (!text) return;

  const lines = text.split(/\r?\n/);

  lines.forEach(line => {
    const [nameRaw, genderRaw] = line.split(',');
    const name = nameRaw?.trim();
    const gender = genderRaw?.trim() || "Male";

    if (name && !players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
      players.push({ name, gender });
    }
  });

  updatePlayerList();
  updateFixedPairSelectors();
  hideImportModal();
}

function addPlayer() {
  const name = document.getElementById('player-name').value.trim();
  const gender = document.getElementById('player-gender').value;

  if (name && !players.some(p => p.name.toLowerCase() === name.toLowerCase())) {
    players.push({ name, gender });
    updatePlayerList();
    updateFixedPairSelectors();
  } else if (name) {
    alert(`Player "${name}" already exists!`);
  }

  document.getElementById('player-name').value = '';
}

function editPlayer(i, field, val) {
  players[i][field] = val.trim();
  updateFixedPairSelectors();
}

function deletePlayer(i) {
  players.splice(i, 1);
  updatePlayerList();
  updateFixedPairSelectors();
}

function updatePlayerList() {
  const table = document.getElementById('player-list-table');
  table.innerHTML = '<tr><th>Name</th><th>Gender</th><th>Action</th></tr>';
  players.forEach((p, i) => {
    const row = document.createElement('tr');
    row.innerHTML = `
      <td><input type="text" value="${p.name}" onchange="editPlayer(${i}, 'name', this.value)"></td>
      <td>
        <select onchange="editPlayer(${i}, 'gender', this.value)">
          <option value="Male" ${p.gender === 'Male' ? 'selected' : ''}>Male</option>
          <option value="Female" ${p.gender === 'Female' ? 'selected' : ''}>Female</option>
        </select>
      </td>
      <td><button class="delete-btn" onclick="deletePlayer(${i})">Delete</button></td>
    `;
    table.appendChild(row);
  });
}

/* =========================
   FIXED PAIRS
========================= */
function updateFixedPairSelectors() {
  const sel1 = document.getElementById('fixed-pair-1');
  const sel2 = document.getElementById('fixed-pair-2');

  // Get all players who are already fixed in pairs
  const pairedPlayers = new Set(fixedPairs.flat());

  sel1.innerHTML = '<option value="">-- Select Player 1 --</option>';
  sel2.innerHTML = '<option value="">-- Select Player 2 --</option>';

  players.forEach(p => {
    if (!pairedPlayers.has(p.name)) {
      const option1 = document.createElement('option');
      const option2 = document.createElement('option');
      option1.value = option2.value = p.name;
      option1.textContent = option2.textContent = p.name;
      sel1.appendChild(option1);
      sel2.appendChild(option2);
    }
  });
}

function addFixedPair() {
  const p1 = document.getElementById('fixed-pair-1').value;
  const p2 = document.getElementById('fixed-pair-2').value;

  if (!p1 || !p2) {
    alert("Please select both players.");
    return;
  }

  if (p1 === p2) {
    alert("You cannot pair the same player with themselves.");
    return;
  }

  const pairKey = [p1, p2].sort().join('&');

  // Check for duplicate pair
  const alreadyExists = fixedPairs.some(pair => pair.sort().join('&') === pairKey);
  if (alreadyExists) {
    alert(`Fixed pair "${p1} & ${p2}" already exists.`);
    return;
  }

  // Add the pair
  fixedPairs.push([p1, p2]);

  // Add to UI
  const div = document.createElement('div');
  div.classList.add('fixed-pair-item');
  div.innerHTML = `
    ${p1} & ${p2} 
    <span class="fixed-pair-remove" onclick="removeFixedPair(this, '${p1}', '${p2}')">
      Remove
    </span>`;
  document.getElementById('fixed-pair-list').appendChild(div);

  // Refresh dropdowns to hide paired players
  updateFixedPairSelectors();
}

function removeFixedPair(el, p1, p2) {
  // Remove from data
  const pairKey = [p1, p2].sort().join('&');
  fixedPairs = fixedPairs.filter(pair => pair.sort().join('&') !== pairKey);

  // Remove from UI
  el.parentElement.remove();

  // Refresh dropdowns to show players again
  updateFixedPairSelectors();
}

function removeFixedPair(el, p1, p2) {
  fixedPairs = fixedPairs.filter(pair => !(pair[0] === p1 && pair[1] === p2));
  el.parentElement.remove();
}

/* =========================
   SCHEDULER INIT
========================= */

function initScheduler(playersList, numCourts, fixedPairs = []) {
  // Reverse and store the player list
  schedulerState.players = [...playersList].reverse();

  schedulerState.numCourts = numCourts;
  schedulerState.fixedPairs = fixedPairs;
  schedulerState.restCount = new Map(playersList.map(p => [p, 0]));
  schedulerState.playedTogether = new Map();
  schedulerState.fixedMap = new Map();
  schedulerState.playedAgainst = new Set();
  schedulerState.pairPlayedSet = new Set();
  // Map fixed pairs for quick lookups
  fixedPairs.forEach(([a, b]) => {
    schedulerState.fixedMap.set(a, b);
    schedulerState.fixedMap.set(b, a);
  });

  schedulerState.roundIndex = 0;
}


/* =========================
   ROUND GENERATOR
========================= */

function shuffle(array) {

  for (let i = array.length - 1; i > 0; i--) {

    const j = Math.floor(Math.random() * (i + 1));

    [array[i], array[j]] = [array[j], array[i]];

  }

  return array;

}

function findDisjointPairs(playing, usedPairsSet, requiredPairsCount) {
  // Build pair lists
  const allPairs = [];
  const unusedPairs = [];
  const usedPairs = [];

  for (let i = 0; i < playing.length; i++) {
    for (let j = i + 1; j < playing.length; j++) {
      const a = playing[i], b = playing[j];
      const key = [a, b].slice().sort().join("&");
      allPairs.push({ a, b, key });
      if (!usedPairsSet || !usedPairsSet.has(key)) unusedPairs.push({ a, b, key });
      else usedPairs.push({ a, b, key });
    }
  }

  // Helper that runs backtracking on a candidate list (array of {a,b,key})
  function backtrack(candidates) {
    const result = [];
    const usedPlayers = new Set();

    function dfs(start) {
      if (result.length === requiredPairsCount) return true;
      for (let i = start; i < candidates.length; i++) {
        const { a, b } = candidates[i];
        if (usedPlayers.has(a) || usedPlayers.has(b)) continue;
        usedPlayers.add(a); usedPlayers.add(b);
        result.push([a, b]);
        if (dfs(i + 1)) return true;
        // backtrack
        result.pop();
        usedPlayers.delete(a); usedPlayers.delete(b);
      }
      return false;
    }

    return dfs(0) ? result.slice() : null;
  }

  // 1) Try with unused pairs only (preferred)
  if (unusedPairs.length >= requiredPairsCount) {
    const res = backtrack(unusedPairs);
    if (res && res.length === requiredPairsCount) return res;
  }

  // 2) Try combination: unused pairs first then used pairs
  const combined = [...unusedPairs, ...usedPairs];
  if (combined.length >= requiredPairsCount) {
    const res = backtrack(combined);
    if (res && res.length === requiredPairsCount) return res;
  }

  // 3) As final fallback, try all pairs (same as combined but ensures full search)
  if (allPairs.length >= requiredPairsCount) {
    const res = backtrack(allPairs);
    if (res && res.length === requiredPairsCount) return res;
  }

  // if still not possible, return empty array
  return [];
}
  
        

 


 



 function AischedulerNextRound() {
  const {
    players,
    numCourts,
    fixedPairs = [],
    restCount,
    playedTogether,
    playedAgainst,
    fixedMap = new Map(),
    pairPlayedSet = new Set()
  } = schedulerState;

  const totalPlayers = players.length;
  const numPlayersPerRound = numCourts * 4;
  const numResting = Math.max(totalPlayers - numPlayersPerRound, 0);

  schedulerState.roundIndex = (schedulerState.roundIndex || 0) + 1;
  const roundIdx = schedulerState.roundIndex;
// Total possible pairs = nC2
const totalPossiblePairs = (schedulerState.players.length * (schedulerState.players.length - 1)) / 2;

// If all pairs have been seen, reset for fresh scheduling
if (schedulerState.pairPlayedSet.size >= totalPossiblePairs) {
  console.log("♻️ All pairs have played together once. Resetting pairing memory...");

  schedulerState.pairPlayedSet.clear();
  schedulerState.playedTogether.clear();
  schedulerState.playedAgainst.clear();

  // Optional: also reset rest counts if you want a full cycle reset
  // schedulerState.restCount = new Map();
}

  // 1) Fair resting selection: sort by restCount ascending
  const sortedPlayers = [...players].sort((a, b) => (restCount.get(a) || 0) - (restCount.get(b) || 0));

  // initial resting
  let resting = sortedPlayers.slice(0, numResting);

  // ensure fixedMap partners rest together
  for (const p of [...resting]) {
    if (fixedMap.has(p)) {
      const partner = fixedMap.get(p);
      if (!resting.includes(partner)) resting.push(partner);
    }
  }

  // if fixedMap caused too many resting, reduce by removing most-rested until fits
  while (players.length - resting.length < numPlayersPerRound && resting.length > 0) {
    let mostRested = resting[0];
    for (const r of resting) {
      if ((restCount.get(r) || 0) > (restCount.get(mostRested) || 0)) mostRested = r;
    }
    resting = resting.filter(p => p !== mostRested);
  }

  // final playing list
  const playing = players.filter(p => !resting.includes(p)).slice(0, numPlayersPerRound);

  // 2) Update restCount and build restingWithNumber
  const restingWithNumber = resting.map(p => {
    restCount.set(p, (restCount.get(p) || 0) + 1);
    return `${p}#${restCount.get(p)}`;
  });

  // 3) Determine required number of pairs
  const requiredPairsCount = Math.floor(numPlayersPerRound / 2);
  if (requiredPairsCount === 0) {
    return { round: roundIdx, resting: restingWithNumber, playing, games: [] };
  }

  // 4) Use findDisjointPairs to get disjoint pairs preferring unused
  const selectedPairs = findDisjointPairs(playing, pairPlayedSet, requiredPairsCount);

  // If helper failed (edge cases), fallback to greedy pairing without repeats where possible
  let finalPairs = selectedPairs;
  if (!finalPairs || finalPairs.length < requiredPairsCount) {
    // Greedy fallback: attempt to build pairs by preferring unused pair keys
    const free = playing.slice();
    const usedPlayers = new Set();
    finalPairs = [];
    for (let i = 0; i < free.length; i++) {
      const a = free[i];
      if (usedPlayers.has(a)) continue;
      // find best partner (prefer one not used with a)
      let chosenIdx = -1;
      for (let j = i + 1; j < free.length; j++) {
        const b = free[j];
        if (usedPlayers.has(b)) continue;
        const key = [a, b].slice().sort().join("&");
        // prefer not-in pairPlayedSet
        if (!pairPlayedSet.has(key)) {
          chosenIdx = j;
          break;
        }
        if (chosenIdx === -1) chosenIdx = j; // keep a fallback
      }
      if (chosenIdx !== -1) {
        const b = free[chosenIdx];
        finalPairs.push([a, b]);
        usedPlayers.add(a); usedPlayers.add(b);
      }
      if (finalPairs.length === requiredPairsCount) break;
    }
    // if still short, pad by pairing remaining sequentially
    if (finalPairs.length < requiredPairsCount) {
      const leftovers = playing.filter(p => !usedPlayers.has(p));
      for (let i = 0; i + 1 < leftovers.length && finalPairs.length < requiredPairsCount; i += 2) {
        finalPairs.push([leftovers[i], leftovers[i + 1]]);
      }
    }
  }

  // 5) Form games: pair pairs into games (two pairs per court)
  const games = [];
  for (let i = 0; i < finalPairs.length; i += 2) {
    if (i + 1 >= finalPairs.length) break; // need two pairs for a match
    const pair1 = finalPairs[i].slice();
    const pair2 = finalPairs[i + 1].slice();
    const matchupKey = [...pair1, ...pair2].map(p => p.toLowerCase()).sort().join("&");
    games.push({ court: games.length + 1, pair1, pair2 });
    playedAgainst.add(matchupKey);
  }

  // 6) Update pair histories (pairPlayedSet, playedTogether)
  for (const pr of finalPairs) {
    const key = pr.slice().sort().join("&");
    pairPlayedSet.add(key);
    playedTogether.set(key, roundIdx);
  }

  // 7) Return round
  return {
    round: roundIdx,
    resting: restingWithNumber,
    playing,
    games
  };
}




/* =========================
   ROUND DISPLAY
========================= */
/* -------------------- MAIN DISPLAY -------------------- */
function showRound(index) {
  const resultsDiv = document.getElementById('game-results');
  resultsDiv.innerHTML = '';
  const data = allRounds[index];
  if (!data) return;

  document.getElementById("roundTitle").className = "round-title";
document.getElementById("roundTitle").innerText = `Round ${data.round}`;


  //document.getElementById("roundTitle").innerText = `Round ${data.round}`;

  const restDiv = renderRestingPlayers(data, index);
  const gamesDiv = renderGames(data, index);
  resultsDiv.append(restDiv, gamesDiv);

  document.getElementById('prevBtn').disabled = index === 0;
  document.getElementById('nextBtn').disabled = false;
}

/* -------------------- RESTING PLAYERS -------------------- */
function renderRestingPlayers(data, index) {
  const restDiv = document.createElement('div');
  restDiv.className = 'round-header';

  const title = document.createElement('div');
  title.innerText = 'Resting:';
  restDiv.appendChild(title);

  const restBox = document.createElement('div');
  restBox.className = 'rest-box';

  // Drop area for team → rest
  //restBox.addEventListener('dragover', (e) => e.preventDefault());
  //restBox.addEventListener('drop', (e) => handleDropToRestArea(e, data, index));

  if (data.resting.length === 0) {
    const span = document.createElement('span');
    span.innerText = 'None';
    restBox.appendChild(span);
  } else {
    data.resting.forEach(player => {
      restBox.appendChild(makeRestButton(player, data, index));
    });
  }

  restDiv.appendChild(restBox);
  return restDiv;
}

/* -------------------- GAMES -------------------- */
function renderGames(data, index) {
  const wrapper = document.createElement('div');

  data.games.forEach((game, gameIndex) => {
    const card = document.createElement('div');
    card.className = 'match-card';

    const teamsDiv = document.createElement('div');
    teamsDiv.className = 'teams';

    const team1 = document.createElement('div');
    team1.className = 'team';
    game.pair1.forEach((p, i) =>
      team1.appendChild(makePlayerButton(p, 'L', gameIndex, i, data, index))
    );

    const vs = document.createElement('span');
    vs.className = 'vs';
    vs.innerText = 'VS';

    const team2 = document.createElement('div');
    team2.className = 'team';
    game.pair2.forEach((p, i) =>
      team2.appendChild(makePlayerButton(p, 'R', gameIndex, i, data, index))
    );

    teamsDiv.append(team1, vs, team2);
    card.appendChild(teamsDiv);
    wrapper.appendChild(card);
  });

  return wrapper;
}

/* -------------------- BUTTON CREATION -------------------- */
function makePlayerButton(name, teamSide, gameIndex, playerIndex, data, index) {
  const btn = document.createElement('button');
  btn.className = teamSide === 'L' ? 'Lplayer-btn' : 'Rplayer-btn';
  btn.innerText = name;
  btn.draggable = true;

  // Start drag
  btn.addEventListener('dragstart', (e) => {
    e.dataTransfer.setData('text/plain', JSON.stringify({
      type: 'team',
      player: name,
      fromTeamSide: teamSide,
      fromGameIndex: gameIndex,
      fromPlayerIndex: playerIndex
    }));
  });

  // Handle drop (rest → team or team → team)
  btn.addEventListener('dragover', (e) => e.preventDefault());
  btn.addEventListener('drop', (e) => {
    const drop = JSON.parse(e.dataTransfer.getData('text/plain'));
    if (drop.type === 'rest') {
      handleDropRestToTeam(e, teamSide, gameIndex, playerIndex, data, index);
    } else if (drop.type === 'team') {
      handleDropBetweenTeams(e, teamSide, gameIndex, playerIndex, data, index);
    }
  });

  return btn;
}

function makeRestButton(player, data, index) {
  const btn = document.createElement('button');
  btn.innerText = player;
  btn.className = 'rest-btn';
  btn.draggable = true;

  const match = player.match(/\.?#(\d+)/);
  if (match) {
    const num = parseInt(match[1]);
    const hue = (num * 40) % 360;
    btn.style.backgroundColor = `hsl(${hue}, 65%, 45%)`;
  } else {
    btn.style.backgroundColor = '#777';
  }
  btn.style.color = 'white';

  btn.addEventListener('dragstart', (e) => {
    e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'rest', player }));
  });

  return btn;
}

/* -------------------- DROP HANDLERS -------------------- */

// 🟢 Rest → Team
function handleDropRestToTeam(e, teamSide, gameIndex, playerIndex, data, index) {
  const drop = JSON.parse(e.dataTransfer.getData('text/plain'));
  if (drop.type !== 'rest') return;

  const teamKey = teamSide === 'L' ? 'pair1' : 'pair2';
  const restIndex = data.resting.indexOf(drop.player);
  if (restIndex === -1) return;

  const baseNewPlayer = drop.player.replace(/#\d+$/, '');
  const oldPlayer = data.games[gameIndex][teamKey][playerIndex];
  data.games[gameIndex][teamKey][playerIndex] = baseNewPlayer;

  const { restCount, playedTogether, playedAgainst } = schedulerState;

  // 1️⃣ Update rest counts
  if (oldPlayer && oldPlayer !== '(Empty)') {
    const cleanOld = oldPlayer.replace(/#\d+$/, '');
    const newCount = (restCount.get(cleanOld) || 0) + 1;
    restCount.set(cleanOld, newCount);
    data.resting[restIndex] = `${cleanOld}#${newCount}`;
  } else {
    data.resting[restIndex] = null;
  }

  restCount.set(baseNewPlayer, Math.max((restCount.get(baseNewPlayer) || 0) - 1, 0));
  data.resting = data.resting.filter(p => p && p !== '(Empty)');

  // 2️⃣ Update relationships
  const thisGame = data.games[gameIndex];
  const pair1 = thisGame.pair1.filter(p => p && p !== '(Empty)');
  const pair2 = thisGame.pair2.filter(p => p && p !== '(Empty)');

  const pairKey = (a, b) => [a, b].sort().join("&");
  const matchupKey = [...pair1, ...pair2].map(p => p.toLowerCase()).sort().join("&");

  if (oldPlayer && oldPlayer !== '(Empty)') {
    const cleanOld = oldPlayer.replace(/#\d+$/, '');
    [...pair1, ...pair2].forEach(p => {
      const cleanP = p.replace(/#\d+$/, '');
      if (cleanP !== cleanOld) {
        playedTogether.delete(pairKey(cleanOld, cleanP));
        playedAgainst.delete(pairKey(cleanOld, cleanP));
      }
    });
  }

  const teammates = teamSide === 'L' ? pair1 : pair2;
  const opponents = teamSide === 'L' ? pair2 : pair1;
  teammates.forEach(tp => {
    const cleanTp = tp.replace(/#\d+$/, '');
    if (cleanTp !== baseNewPlayer) {
      playedTogether.set(pairKey(baseNewPlayer, cleanTp), schedulerState.roundIndex);
    }
  });
  playedAgainst.add(matchupKey);

  showRound(index);
}


// 🔵 Team → Team (swap)
function handleDropBetweenTeams(e, teamSide, gameIndex, playerIndex, data, index) {
  const drop = JSON.parse(e.dataTransfer.getData('text/plain'));
  if (drop.type !== 'team') return;

  const { fromTeamSide, fromGameIndex, fromPlayerIndex, player } = drop;
  if (!player || player === '(Empty)') return;

  const fromTeamKey = fromTeamSide === 'L' ? 'pair1' : 'pair2';
  const toTeamKey = teamSide === 'L' ? 'pair1' : 'pair2';
  const fromTeam = data.games[fromGameIndex][fromTeamKey];
  const toTeam = data.games[gameIndex][toTeamKey];

  const movedPlayer = player.replace(/#\d+$/, '');
  const targetPlayer = toTeam[playerIndex];

  // Swap
  toTeam[playerIndex] = movedPlayer;
  fromTeam[fromPlayerIndex] = targetPlayer && targetPlayer !== '(Empty)' ? targetPlayer : '(Empty)';

  updateRelationships(data, gameIndex);
  updateRelationships(data, fromGameIndex);
  showRound(index);
}

// 🔴 Team → Rest
function handleDropToRestArea(e, data, index) {
  const drop = JSON.parse(e.dataTransfer.getData('text/plain'));
  if (drop.type !== 'team') return;

  const { fromTeamSide, fromGameIndex, fromPlayerIndex, player } = drop;
  const teamKey = fromTeamSide === 'L' ? 'pair1' : 'pair2';
  const team = data.games[fromGameIndex][teamKey];

  // Remove player from team
  team[fromPlayerIndex] = '(Empty)';

  // Add to resting
  if (!data.resting.includes(player)) data.resting.push(player);

  updateRelationships(data, fromGameIndex);
  showRound(index);
}

/* -------------------- RELATIONSHIP TRACKING -------------------- */
function updateRelationships(data, gameIndex) {
  const { playedTogether, playedAgainst } = schedulerState;
  const game = data.games[gameIndex];
  const pair1 = game.pair1.filter(p => p && p !== '(Empty)');
  const pair2 = game.pair2.filter(p => p && p !== '(Empty)');

  const pairKey = (a, b) => [a, b].sort().join("&");
  const matchupKey = [...pair1, ...pair2].map(p => p.toLowerCase()).sort().join("&");

  // Remove existing
  [...pair1, ...pair2].forEach(a => {
    [...pair1, ...pair2].forEach(b => {
      if (a !== b) playedTogether.delete(pairKey(a, b));
    });
  });
  playedAgainst.delete(matchupKey);

  // Add new
  pair1.forEach(a => pair1.forEach(b => {
    if (a !== b) playedTogether.set(pairKey(a, b), schedulerState.roundIndex);
  }));
  pair2.forEach(a => pair2.forEach(b => {
    if (a !== b) playedTogether.set(pairKey(a, b), schedulerState.roundIndex);
  }));

  playedAgainst.add(matchupKey);
}

  


      
function showRoundold(index) {
  const resultsDiv = document.getElementById('game-results');
  resultsDiv.innerHTML = '';
  const data = allRounds[index];
  if (!data) return;

  document.getElementById("roundTitle").innerText = `Round ${data.round}`;
  //const restDiv = document.createElement('div');
  //restDiv.className = 'round-header';
  //restDiv.innerText = `Resting: ${data.resting.join(', ') || 'None'}`;
  //resultsDiv.appendChild(restDiv);

  const restDiv = document.createElement('div');
restDiv.className = 'round-header';

const title = document.createElement('div');
title.innerText = 'Resting:';
restDiv.appendChild(title);

const restBox = document.createElement('div');
restBox.className = 'rest-box';

if (data.resting.length > 0) {
  data.resting.forEach(player => {
    const btn = document.createElement('button');
    btn.innerText = player;
    btn.className = 'rest-btn';

    // Match either "#number" or ".#number" anywhere in the string
    const match = player.match(/\.?#(\d+)/);
    if (match) {
      const num = parseInt(match[1]);
      // create color based on number for uniqueness
      const hue = (num * 40) % 360;
      btn.style.backgroundColor = `hsl(${hue}, 65%, 45%)`;
      btn.style.color = 'white';
    } else {
      // fallback color if no #number found
      btn.style.backgroundColor = '#777';
      btn.style.color = 'white';
    }

    restBox.appendChild(btn);
  });
} else {
  const noneSpan = document.createElement('span');
  noneSpan.innerText = 'None';
  restBox.appendChild(noneSpan);
}

restDiv.appendChild(restBox);
resultsDiv.appendChild(restDiv);
  data.games.forEach(g => {
    const card = document.createElement('div');
    card.className = 'match-card';
    const teamsDiv = document.createElement('div');
    teamsDiv.className = 'teams';

    const team1 = document.createElement('div');
    team1.className = 'team';
    g.pair1.forEach(p => {
      const btn = document.createElement('button');
      btn.className = 'Lplayer-btn';
      btn.innerText = p;
      team1.appendChild(btn);
    });

    const vs = document.createElement('span');
    vs.className = 'vs';
    vs.innerText = 'VS';

    const team2 = document.createElement('div');
    team2.className = 'team';
    g.pair2.forEach(p => {
      const btn = document.createElement('button');
      btn.className = 'Rplayer-btn';
      btn.innerText = p;
      team2.appendChild(btn);
    });

    teamsDiv.append(team1, vs, team2);
    card.appendChild(teamsDiv);
    resultsDiv.appendChild(card);
  });

  document.getElementById('prevBtn').disabled = index === 0;
  document.getElementById('nextBtn').disabled = false;
}

/* =========================
   NAVIGATION
========================= */

function goToRounds() {

const numCourts = parseInt(document.getElementById('num-courts').value);

if (!players.length || !numCourts) {

alert('Please add players and number of courts!');

return;

}

    if (allRounds.length === 0) {

        initScheduler(players.map(p => p.name), numCourts, fixedPairs);

        allRounds = [ AischedulerNextRound()];

        currentRoundIndex = 0;

        showRound(0);

    } else {
            const playersList = players.map(p => p.name);

            schedulerState.players = [...playersList].reverse();

            schedulerState.numCourts = numCourts;

            schedulerState.fixedPairs = fixedPairs;

            schedulerState.fixedMap = new Map();

            // Add new players (who are not already in restCount)
            let highestRestCount = -Infinity;
            let highestPlayers = [];

            for (const p of playersList) {
              if (schedulerState.restCount.has(p)) {
              const count = schedulerState.restCount.get(p);

                if (count > highestRestCount) {
                  highestRestCount = count;
                  highestPlayers = [p]; // reset with new highest
                } else if (count === highestRestCount) {
                  highestPlayers.push(p); // tie — add player
                }
              }
            }

            for (const p of playersList) {

                if (!schedulerState.restCount.has(p)) {

                    schedulerState.restCount.set(p, highestRestCount+1); // initialize new player

                }

            }

 

            // Optionally, remove restCount entries for players no longer in playersList

            for (const p of Array.from(schedulerState.restCount.keys())) {

                if (!playersList.includes(p)) {

                    schedulerState.restCount.delete(p);

                }

            }           

        if (currentRoundIndex + 1 <= allRounds.length) {

            showRound(currentRoundIndex);

        } else {

           
            allRounds.push(AischedulerNextRound());

            currentRoundIndex = currentRoundIndex + 1;

            showRound(currentRoundIndex);

}

    }

document.getElementById('page1').style.display = 'none';

document.getElementById('page2').style.display = 'block';

isOnPage2 = true;

disablePullToRefresh();

}


function goBack() {
  const pin = prompt("Enter 4-digit code to go back:");
  if (pin === "0000") {
    document.getElementById('page1').style.display = 'block';
    document.getElementById('page2').style.display = 'none';
    isOnPage2 = false;
  enablePullToRefresh(); // 🔓 re-enables refresh
  } else if (pin !== null) alert("Incorrect PIN!");
}

function nextRound() {
  if (currentRoundIndex + 1 < allRounds.length) {
    currentRoundIndex++;
    showRound(currentRoundIndex);
  } else {
    const newRound = AischedulerNextRound();
    allRounds.push(newRound);
    currentRoundIndex = allRounds.length - 1;
    showRound(currentRoundIndex);
  }
}

function prevRound() {
  if (currentRoundIndex > 0) {
    currentRoundIndex--;
    showRound(currentRoundIndex);
  }
}

// Prevent pull-to-refresh and accidental reload on mobile
document.addEventListener('touchmove', function (event) {
  if (event.touches.length > 1) {
    event.preventDefault(); // Disable multi-touch zoom
  }
}, { passive: false });

window.addEventListener('beforeunload', function (e) {
  // Optional: warn if they try to reload or close
  e.preventDefault();
  e.returnValue = ''; // Chrome requires returnValue to show prompt
});
</script>


</body>
</html>
































